package net.sharplab.epubtranslator.core.service

import net.sharplab.epubtranslator.core.driver.translator.Translator
import org.junit.jupiter.api.Test
import java.io.Console

internal class EPubTranslatorServiceImplTest{

    private val ePubTranslatorService = EPubTranslatorServiceImpl(MockTranslator())

    @Test
    fun test(){
        val xmlString = """
<?xml version="1.0" encoding="utf-8" ?>

<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.1//EN" "http://www.w3.org/TR/xhtml11/DTD/xhtml11.dtd">

<html xmlns="http://www.w3.org/1999/xhtml"><head><title>Chapter&#xA0;1.&#xA0;Getting Started</title><link rel="stylesheet" href="epub.css" type="text/css"/><meta name="generator" content="DocBook XSL Stylesheets V1.75.2"/></head><body id="page"><div class="chapter" title="Chapter&#xA0;1.&#xA0;Getting Started"><div class="titlepage"><div><div><h1 class="title"><a id="ch01"/>Chapter&#xA0;1.&#xA0;Getting Started</h1></div></div></div><p>With the advent of Cloud technology, many paradigms started to change, like the way the industry tackles issues related data security and user privacy. Even the most conservative and traditional organizations have been forced to start adapting to this new technology, and are trying to use one of the many existent cloud platforms.</p><p>There are numerous benefits offered by cloud computing, both to end users and companies of all sizes and shapes. For small companies, they are a good option because it can minimize licensing software, and for big companies that want to expand their business, cloud computing can help improve accessibility without the need to spend too much money on hardware.</p><p>Moving to the field of data, a few years ago, managers and even developers assumed that nearly all data should be stored in a Relational Database Management System (RDBMS). Some years ago, it was unthinkable to run a production system that kept all of its data within memory, but now, due to the continuous decline in the prices of RAM, modern in-memory products are emerging such as big data analytics tools (in-memory computation) and in-memory data grids. One such in-memory data grid system is Infinispan.</p><p>Infinispan is an<a id="id0" class="indexterm"/> open source data grid platform distributed by JBoss, written in Java; it exposes a JSR-107 compatible cache interface in which you can store objects.</p><p>This first chapter launches you on a tour of this technology by focusing on fundamentals.</p><p>In this chapter, we will cover the following topics:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Introducing the Infinispan data grid</li><li class="listitem" style="list-style-type: disc">Infinispan and JSR 107 &#x2013; Java Temporary Caching API</li><li class="listitem" style="list-style-type: disc">Getting started with Infinispan</li><li class="listitem" style="list-style-type: disc">Running the sample application</li><li class="listitem" style="list-style-type: disc">Creating your first project</li><li class="listitem" style="list-style-type: disc">Building Infinispan from source</li><li class="listitem" style="list-style-type: disc">Contributing to the project</li></ul></div><div class="section" title="Introducing the Infinispan data grid"><div class="titlepage"><div><div><h1 class="title"><a id="ch01lvl1sec08"/>Introducing the Infinispan data grid</h1></div></div></div><p>Generally, data grids are<a id="id1" class="indexterm"/> considered an evolution of distributed caches. As the name implies, a distributed cache is characterized by the usage of multiple servers to host cached data, so that it can grow in size and in capacity. A distributed cache solution is mainly used to store<a id="id2" class="indexterm"/> temporary application data, such as web session data.</p><p>There are several benefits to<a id="id3" class="indexterm"/> using an in-memory data grid like Infinispan; a good and simple example is database offloading. Database offloading is the process of removing or reducing the database load, mainframes, and shared or partner services.</p><p>As mentioned in the introduction, Cloud platforms are also changing the way we store and distribute our data. A common solution adopted on cloud architectures is to expose the data through REST services.</p><p>In these cloud architectures, applications that expose the business data via REST services to clients normally decompose the system into layers, in order to separate the user interface from the business logic, as illustrated in the following image:</p><div class="mediaobject"><img src="graphics/9970OS_01_01.jpg" alt="Introducing the Infinispan data grid"/></div><p>In the image, you can see how the data layer fits in a layered application. In our example, the data layer hides the implementation details to the database. We can consider that the database is a single repository of data, which is accessed at first by a few clients. However, that's the scenario if you're on a cloud environment, things can change fast.</p><p>From the performance point of view, retrieving data for every request from one single repository can be expensive, both in terms of time and hardware cost.</p><p>Also, you may need to provide access to your data for many clients' social media and mobile device integration, which can decrease the performance of your services, thereby impacting user experience.</p><p>This scenario can be a good example of offloading; in our scenario, we designed our database to provide a certain amount of data via REST services, which does not only impact the response time of the database request, but can also impact the whole infrastructure where the data is being transmitted.</p><p>Infinispan can work <a id="id4" class="indexterm"/>well in very demanding environments, as in this scenario. Thoughtful use of a distributed caching to offload the network and database can really improve performance. For instance, when a client makes a web method call to the service layer, which in turn performs several calls to the database, you could cache the query results in an Infinispan cache. Then, the next time this client needs to make the same Web method call, the service layer gets that data from the cache instead. This step can really improve overall performance because the application does not have to make an expensive database call. An Infinispan cache, in this scenario, can also reduce the pressure on the service layer, because data in an Infinispan cache can be distributed among all nodes of the cluster.</p><p>The following figure presents the same architecture as included in the first image, but now with an Infinispan cache:</p><div class="mediaobject"><img src="graphics/9970OS_01_02.jpg" alt="Introducing the Infinispan data grid"/></div><p>At the same time, Infinispan can also power embedded applications, be used as a JPA/Hibernate second-level cache provider, or as a highly available key/value data store.</p><p>The scenario we presented previously is one of the two possible ways you can interact with Infinispan. We are using Infinispan in the embedded mode, which initiates the Infinispan data grid within the same JVM as the application.</p><p>The other way is the client/server mode, where you have an Infinispan data grid instance running in a separated server, which delivers and manages the grid content to be consumed by the client, including non-java clients, such as C++, Python, and .NET.</p><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="tip03"/>Tip</h3><p>We will cover Infinispan Server in detail in <a class="link" href="ch09.html" title="Chapter&#xA0;9.&#xA0;Server Modules">Chapter 9</a>, <span class="emphasis"><em>Server Modules</em></span>.</p></div></div><p>Infinispan also provides an extremely low latency access to the cache, and high availability of the application data<a id="id5" class="indexterm"/>, by keeping the data in the memory and distributing it to several nodes of the grid, which makes your application able to load terabytes of data into memory. However, it not only provides a new attempt to use the main memory as a storage area instead of a disk, (Infinispan perform much faster than disk-based databases) but it also provides features such as:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Data partitioning across a cluster</li><li class="listitem" style="list-style-type: disc">Work with domain objects rather than only bytes, arrays, or strings</li><li class="listitem" style="list-style-type: disc">Synchronous and asynchronous operations throughout</li><li class="listitem" style="list-style-type: disc">Distributed ACID transactions</li><li class="listitem" style="list-style-type: disc">Data distribution through the use of a consistent hash algorithm to determine where keys should be located in the cluster</li><li class="listitem" style="list-style-type: disc">Write-through/behind cache store support</li><li class="listitem" style="list-style-type: disc">Eviction support</li><li class="listitem" style="list-style-type: disc">Elastic scaling</li><li class="listitem" style="list-style-type: disc">Multiple access protocols</li><li class="listitem" style="list-style-type: disc">Support for compute grids</li><li class="listitem" style="list-style-type: disc">Persisting state to configurable cache stores</li></ul></div><p>We will cover all these features in detail throughout this chapter.</p><p>From a Java developer perspective, an Infinispan cache can be seen as a distributed key-value object store similar in its interface to a typical concurrent hash map, in a way that it can have any application domain object as either a value or a key.</p></div></div></body></html>
        """.trimIndent()
        val translated = ePubTranslatorService.translateXmlString(xmlString, "en", "ja");
    }

    class MockTranslator : Translator {
        override fun translate(texts: List<String>, srcLang: String, dstLang: String): List<String> {
            return texts
        }
    }
}